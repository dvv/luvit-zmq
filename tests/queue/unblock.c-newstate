#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "uv.h"

#include "lua.h"
#include "lauxlib.h"

typedef struct {
  lua_State* L;
  lua_State* X;
  uv_work_t work_req;
  int c;
  int r;
} luv_work_t;

static void worker(uv_work_t* req) {
  luv_work_t* ref = req->data;
  lua_State *L = ref->L;
  lua_State *X = ref->X;

  int before = lua_gettop(L);

  /* call the worker */
  printf("WORKING\n");
  lua_rawgeti(L, LUA_REGISTRYINDEX, ref->c);
  luaL_unref(L, LUA_REGISTRYINDEX, ref->c);
  lua_xmove(L, X, 1);
  printf("CALLING\n");
  //luv_acall(L, 0, 0, "queue_work");
  lua_call(X, 0, 0);
  printf("WORKED\n");

  assert(lua_gettop(L) == before);
}

static void after_work(uv_work_t* req) {
  luv_work_t* ref = req->data;
  lua_State *L = ref->L;

  int before = lua_gettop(L);

  /* load the callback and arguments */
  int argc = lua_gettop(ref->X);
  lua_rawgeti(L, LUA_REGISTRYINDEX, ref->r);
  luaL_unref(L, LUA_REGISTRYINDEX, ref->r);
  lua_xmove(ref->X, L, argc);
  assert(lua_gettop(ref->X) == 0);
  /* call back */
  luv_acall(L, argc, 0, "after_work");

  assert(lua_gettop(L) == before);

  /*cleanup */
  lua_close(ref->X);
  free(ref);
}

int luv_queue(lua_State* L) {

  int before = lua_gettop(L);

  luaL_checktype(L, 1, LUA_TFUNCTION);
  luaL_checktype(L, 2, LUA_TFUNCTION);

  luv_work_t* ref = malloc(sizeof(luv_work_t));
  ref->work_req.data = ref;
  ref->L = L;

  /* allocate new state */
  ref->X = luaL_newstate();
  if (ref->X == NULL) {
    return luaL_error(L, "queue: can not allocate new state");
  }
  luaL_openlibs(ref->X);

  /* store callback */
  lua_pushvalue(L, 1);
  ref->c = luaL_ref(L, LUA_REGISTRYINDEX);
  lua_pushvalue(L, 2);
  ref->r = luaL_ref(L, LUA_REGISTRYINDEX);

  if (uv_queue_work(luv_get_loop(L), &ref->work_req, worker, after_work)) {
    uv_err_t err = uv_last_error(luv_get_loop(L));
    return luaL_error(L, "queue: %s", uv_strerror(err));
    //luv_push_async_error(L, err, "queue");
    //return lua_error(L);
  }

  assert(lua_gettop(L) == before);

  return 0;
}

////////////////////////////////////////////////////////////////////////////////

static const luaL_reg exports[] = {
  {"queue", luv_queue},
  {NULL, NULL}
};

LUALIB_API int luaopen_queue(lua_State *L) {

  lua_newtable(L);
  luaL_register(L, NULL, exports);

  // return the new module
  return 1;
}
